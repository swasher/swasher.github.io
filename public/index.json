[{"content":"Планирование дел и хранение информации wunderlist.com - имхо лучший сервис ведения списков (в т.ч. todo)\nkeep.google.com - сервис заметок\nlastpass - синхронизация паролей браузера\nkeeweb.info - хранилище паролей от \u0026ldquo;железа\u0026rdquo; (with dropbox sync)\nОблачные хранилища dropbox.com - синхронизация файлов между копьютерами. Удобно хранить исходники при работе на нескольких девайсах. Free - ~ 22 GB max\nmega.nz - хранение файлов без синхронизации, с шифрованием на стороне клиента. Free - 50GB\nРепозитории исходных кодов github.com – неограниченное количество бесплатных публичных репозиториев;\nbitbucket.org – бесплатные приватные репозитории (GIT и Mercurial), с которыми могут работать до пяти человек;\nCloud Source Repositories – бесплатные приватные GIT-репозитории, развернутые на облачной платформе Google Cloud. Сервис поддерживает синхронизацию с репозиториями GitHub и Bitbucket. Размер хранилища до 500 Мб.\ngitkraken - графический клиент для git\nIDE и редакторы pycharm - лучшая IDE для python\natom.io - текстовый редактор от GitHub\nKoding IDE - онлайн IDE, в вирт. машине Ubuntu, плюс групповая работа\nprose.io - сервис, позволяющий напрямую редактировать файлы в репозитории GitHub\nc9.io - Cloud9 IDE, мощная онлайн IDE\nОнлайн инструменты разработки и тестирования browserling.com - онлайн браузер\nbrowsershots.org - делает скриншот страницы во всех известных браузерах\nmapbox.com - платформа для разработки приложений на основе карт (гео)\nТестирование кода, css, html, js repl.it - запуск кода, поддерживает множество языков\nbootply.com - тестирование html, css, javascript\njsfiddle.net - тестирование html, css, javascript\ncodepen.io - тестирование html, css, javascript\nplaycode.io/ - тестирование html, css, javascript\ncodesandbox.io - полноценная IDE\nbootsnipp.com - множество образцов макетов на бутстрапе, например формы регистрации\nrunnable.io - песочница для запуска приложений, в т.ч python/django\nСУБД mongotron.io - Cross platform MongoDB management. Open Source, built using Electron and Angular JS\nФронтенд getbootstrap.com - bootstrap\nEffeckt.css - css фреймворк от создателей html5 boilerplate. Реализует различные эффекты\nformvalidation.io - очень крутой фреймворк-валидатор форм, интеграция с bootstrap и другими css фрейворками\nbootstrap-validator - валидатор форм для bootstrap\njqueryvalidation.org - валидатор форм на jquery\nparsleyjs.org/ - валидатор форм, очень крутой\nsummernote.org - очень простой интегрируемый редактор на бутстрапе\ntextbox.io - интегрируемый редактор, платный, есть фри версия, вроде бы без ограничений\nbootboxjs.com - js библиотека разнообразных (dialog, modаl, alert, confirm) окон\nШрифты и иконки fontawesome.io - иконки, есть платная версия fortawesome\nglyphicons.com - иконки, в бесплатной версии только базовый набор\nnerdfonts.com - агрегатор иконок\nprogrammingfonts.org - большая коллекция IDE-шрифтов в виде фонт-библиотеки\nPython click.pocoo.org - отличный проект для разработки интерфейса командной строки Утилиты gifcam - маленькая утилита для снятия гифок с экрана. Хостинг netlify.com – хостинг статического сайта или приложения, хранилище 100 Мб, пропускная способность 1 Гб; автоматический деплой при обнаружении изменений в репозитории GitHub\ncloudinary.com - хостинг изображений. Трансформации изображений. Фри план: 7,500 Monthly Transformations,\r75,000 Total Images, 2 GB Managed Storage, 5 GB Monthly Viewing Bandwidth\nfirebase.com - хостинг с бесплатным планом навсегда. В бесплатном плане нет custom domains\nbitballoon.com - хостинг с бесплатным планом на их субдомене\nonline.net - VPS за три евро\novh.com - VPS 3.5 евро (OpenStack KVM, 1 vCore, 2.4 GHz, 2 GB RAM, 10 GB SSD, Local RAID 10)\ndigitalocean.com - один из самых уважаемых хостеров. VPS за 5 долл (512 MB RAM, 1 CoreProcessor, 20GBSSD Disk, 1TBTransfer)\nserverbear.com - сводная информация по всем vps\nPaaS heroku - Heroku одно из немногих мест, где действительно бесплатно и качественно можно развернуть django-приложение.\npaasify.it - подбор Paas по параметрам\nДомены freenom.com - фри домены tk, ml, ga, cf, gq\npop.co - фри домен co\npp.ua - фри домен pp.ua\nПочта mailjet.com - рассылка писем, множество фич. Free - 6000 emails/month\nmailgun.com - The Email Service For Developers. Free - 10k emails/month\nAuth auth0.com - Add authentication to your web. Free for 7k users. ","permalink":"https://swasher.github.io/posts/developer-resources/","summary":"Планирование дел и хранение информации wunderlist.com - имхо лучший сервис ведения списков (в т.ч. todo)\nkeep.google.com - сервис заметок\nlastpass - синхронизация паролей браузера\nkeeweb.info - хранилище паролей от \u0026ldquo;железа\u0026rdquo; (with dropbox sync)\nОблачные хранилища dropbox.com - синхронизация файлов между копьютерами. Удобно хранить исходники при работе на нескольких девайсах. Free - ~ 22 GB max\nmega.nz - хранение файлов без синхронизации, с шифрованием на стороне клиента. Free - 50GB\nРепозитории исходных кодов github.","title":"Инструменты и ресурсы для разработчика"},{"content":"Задача - написать минимальное, но хорошо структурированое приложение-темплейт, использующее в качестве бекенда Flask, фронтэнд - Vue.js, в качестве хоста используем PaaS платформу Heroku. База данных, конечно, Postges, локально для девелопинга SQLite [уточнить], в качестве ORM для Flask я выбрал Peewee вместо обычной SQLAlchemy.\nЭта статья не призвана учить азам vue или flask, больше упор делается на соеденение всех компонентов стека. Поэтому объяснений самого кода будет минимум.\nПервая, неудачная попытка была создать структуру проекта с папками frontend и backend:\nroot/\r├── backend/\r├── frontend/\r│ └── package.json\r├ Procfile\r├ requirements.txt\r└ run.py\rТо есть flask и vue были отделены от корневого каталога. В таком виде оно хорошо работает, но для деплоя на heroku нужно наличие в корне package.json. Это можно побороть скриптами, но я решил попробовать flatten-структуру.\nИтак, приступим:\nVue.js Установим Vue.js, используя опцию -g для глобальной установки.\n$ npm install -g @vue/cli\rСледующая команда создаст корневую директорию для нашего проекта.\n$ cd /home/all_my_projects\r$ vue create flask-vue-heroku --no-git\rPycharm notes: In Settings:Language turn on flask integration.\nВыбираем кастомную установку, пресет линтинга Airbnb, хранение настроек в одном файле. Переходим в папку проекта, и в отдельном терминале запускаем dev-сервер:\n$ cd flask-vue-heroku\r$ npm run serve\rОткрываем в браузере http://localhost:8080/.\nТеперь создадим свой простейший компонент во vue.js. Наш компонент будет показывать версию операционной системы бекенда. Пока что у нас бекенда нет, мы будем просто писать \u0026ldquo;Unknown\u0026rdquo;. Компоненты хранятся в папке src\\components. Удалим оттуда дефолтный HelloWorld.vue и создадим свой Server_os.vue с таким содержимым:\n::html\r\u0026lt;template\u0026gt;\r\u0026lt;p\u0026gt;Server working on: {{ os }}\u0026lt;/p\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rexport default {\rname: 'Server_os',\rdata() {\rreturn {\ros: 'Unknown',\r};\r},\r};\r\u0026lt;/script\u0026gt;\rи в файле src\\App.vue исправим пути и имена:\n\u0026lt;template\u0026gt;\r\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\r\u0026lt;img alt=\u0026quot;Vue logo\u0026quot; src=\u0026quot;./assets/logo.png\u0026quot;\u0026gt;\r\u0026lt;Os/\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt;\r\u0026lt;script\u0026gt;\rimport Os from './components/Server_os.vue';\rexport default {\rname: 'App',\rcomponents: {\rOs,\r},\r};\r\u0026lt;/script\u0026gt;\rМы должны увидеть Server working on: Unknown:\n{% img image https://res.cloudinary.com/swasher/image/upload/v1557519436/blog/flask-vue-1.png %}\nВкратце, что происходит в коде:\npublic/index.html - точка входа. Главное в этом файле - строка \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;, этот id=\u0026lsquo;app\u0026rsquo; фреймворк vue.js заменит на сгенерированный им html-код. src/main.js - в этом файле загружается и инициализируется vue. Тут же мы указываем, что сгенерированный код будет помещен в контейнер с id=app. Во второй строке подгружается \u0026lsquo;главный\u0026rsquo; компонент \u0026lsquo;App.vue\u0026rsquo;, в который, в свою очередь, будут подгружаться все созданные нами компоненты. src/App.vue - \u0026lsquo;главный\u0026rsquo; (root) компонент. Как и любой компонент, состоит из раздела template - это html-темплейт наподобие Jinja,\nраздела script, который этот темплейт преобразует в собственно html и возвращает как результат работы компонента, и раздел style, который содержит CSS-стили для этого компонента. src/components/Server_os.vue - это наш рабочий компонент, который подключается в главный App.vue. Содержит те же разделы. В разделе script немного другой синтаксис - компонент объявляется как export default и указывается свойство name (\u0026lsquo;Server_os\u0026rsquo;). Под этим именем он может импортироваться в другие компоненты (переиспользоваться). Свойство data содержит функцию - она возвращает некие данные для использования в темплейте. У нас она пока-что возвращает просто переменную os со значением \u0026lsquo;Unknown\u0026rsquo;. Фронт-энд часть у нас работает, займемся бекэнд. Сделаем так, чтобы серверный код передавал на фронтэнд название операционной системы сервера.\nFlask $ cd flask-vue-heroku\r$ pipenv install flask\rPycharm notes: Mark venv directory as excluded in Settings:Project Structure.\nСоздадим в корне app.py:\n::python\rfrom flask import Flask, jsonify\rimport platform\rapp = Flask(__name__)\r@app.route('/')\rdef get_os_name():\rp = platform.platform()\rreturn jsonify({'platform': p})\rПо ссылке / фласк будет отдавать данные в формате json.\nНужно установить переменную окружения (в винде вот так):\n\u0026gt; set FLASK_ENV=development\rЗапускаем flask -flask run и смотрим, что у нас на 5000 порту:\n::json\r{\r\u0026quot;platform\u0026quot;: \u0026quot;Windows-7-6.1.7601-SP1\u0026quot;\r}\rFlask возвращает данные в виде json-объекта. Сейчас мы можем запустить одновременно обе части приложения - в одной консоле flask, в другой vue.js\n{% img lb-image https://res.cloudinary.com/swasher/image/upload/v1557565280/blog/flask-vue-2.png 760 %}\nAxios Теперь попробуем объеденить наши фронтэнд и бекенд, и передать между ними какую-то информацию. Vue.js будет обращаться к бекенду с помощью ajax запросов, и мы будем выполнять эти запросы с помощью библиотеки axios.\n$ npm install axios --save Напишем \u0026ldquo;принимающую\u0026rdquo; сторону - яваскрипт, который из браузера будет обращаться к серверу и получать оттуда данные. Для этого модифицируем Server_os.vue следующим образом\n\u0026lt;script\u0026gt;\rimport axios from 'axios';\rexport default {\rname: 'Server_os',\rdata() {\rreturn {\ros: 'Unknown',\r};\r},\rmethods: {\rgetOs() {\rconst path = 'http://localhost:5000/';\raxios.get(path)\r.then((response) =\u0026gt; {\rthis.os = response.data.platform;\r})\r.catch((error) =\u0026gt; {\r// eslint-disable-next-line\rconsole.error(error);\r});\r},\r},\rcreated() {\rthis.getOs();\r},\r};\r\u0026lt;/script\u0026gt;\rЧто здесь происходит:\nимя компонента - Server_os, оно будет видно в отладчике Vue в хроме data() - указываем, что компонент будет возвращать os далее создаем метод getOs, который выполняет ajax запрос по пути path ajax возвращает объект response из этого объекта берем данные по ключу platform (response.data.platform) и возвращаем их через this.os хук created запуская метод при инициализации экземпляра Vue Теперь мы должны увидеть ответ Server working on: Windows-7-6.1.7601-SP1, но этого не происходит, ответ пустой. Запускаем отладчик Chrome и видим такую ошибку\n::bash\rAccess to XMLHttpRequest at 'http://localhost:5000/' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.\r{% img lb-image https://res.cloudinary.com/swasher/image/upload/v1557569338/blog/flask-vue-3.png 760 %}\nЭто происходит потому, что flask в целях безопасности запрещает обращение с другого домена (или порта, в нашем случае). Чтобы это пофиксить, ставим библиотеку flask-cors: pipenv install -U flask-cors и добавим две строчки в app.py\n::python\rfrom flask_cors import CORS\rapp = Flask(__name__)\r# enable CORS\rCORS(app)\rСмотрим еще раз:\n{% img lb-image https://res.cloudinary.com/swasher/image/upload/v1557570857/blog/flask-vue-4.png 760 %}\nВсе работает, фронтэнд принимает данные от бекенда. На этом будем считать первую версию приложения законченной и перейдем к деплою на Heroku. После удачного деплоя попробуем усложнить приложиние, добавив работу с БД, web-компонентами и т.д.\nВ случае с Django: Устанавливаем пакет pip install django-cors-headers Прописываем нужные модули в INSTALLED_APPS и MIDDLEWARE согласно документации. В settings.py вносим наши адреса, примерно так:\nCORS_ORIGIN_WHITELIST = [\r\u0026quot;http://localhost:8000\u0026quot;,\r\u0026quot;http://192.168.1.121:8080\u0026quot;\r]\rHeroku Внесем необходимые изменения в проект и установим недостающие компоненты.\nHeroku toolbelt Нам понадобится установленный Heroku Toolbelt.\nGunicorn Веб-сервер для python\n::shell\r$ pipenv install gunicorn\rProcfile Создадим Procfile в корне проекта:\n::js\rweb: gunicorn app:app --log-file -\rBuild Heroku будет выполнять устновку всех зависимостей из файла package.json. Затем он вызовет команду postinstall, которая запустит сборку. Создастся директория dist, в которую сборщик поместит сгенерированные файлы css и js\nДобавим строку postinstall в package.json:\n::json-object\r\u0026quot;scripts\u0026quot;: {\r\u0026quot;serve\u0026quot;: \u0026quot;vue-cli-service serve\u0026quot;,\r\u0026quot;build\u0026quot;: \u0026quot;vue-cli-service build\u0026quot;,\r\u0026quot;lint\u0026quot;: \u0026quot;vue-cli-service lint\u0026quot;,\r\u0026quot;postinstall\u0026quot;: \u0026quot;npm run build\u0026quot;\r},\rvue.config.js Создадим в корне проекта файл настроек vue.js. Нужная нам настройка - assetsDir, она указывает путь для генерируемой сборщиком статики (внутри outputDir). outputDir у нас установлен в dist, это пусть для сборки\nmodule.exports = {\rassetsDir: 'static',\routputDir: 'dist',\r};\rFlask Изменим app.py таким образом, чтобы на продакшене он отдавал данные json по ссылке /json, а по ссылке / flask будет отдавать сгенерированный vue.js файл index.html, который находится в /app/dist. Изменим наш app.py следующим образом:\n::python\rfrom flask import Flask, jsonify, send_file\rfrom flask_cors import CORS\rimport platform\rapp = Flask(__name__, static_folder='dist/static')\r# enable CORS\rCORS(app)\r@app.route('/json')\rdef get_os_name():\rp = platform.platform()\rreturn jsonify({'platform': p})\r@app.route('/')\rdef index():\rvuejs_html = '/app/dist/index.html'\rreturn send_file(vuejs_html)\rОчень важная строчка - app = Flask(__name__, static_folder='dist/static'), здесь мы указываем путь к статике, без этого фласк не сможет найти js файлы, которые сгенерировала команда npm run build в папке dist и ничего не заведется.\nКонечно, в Server_os.vue нужно изменить ссылку, откуда получать данные:\n::diff\r- const path = 'http://localhost:5000/';\r+ const path = '/json';\rМы убираем localhost, иначе наше приложение на heroku по-прежнему будет показывать версию операционки нашего десктопа. И пишем /json без указания домена.\ndeploy Пробуем задеплоить\n$ heroku login\r$ git init\r$ heroku apps:create test654888 # any available name\r$ heroku git:remote --app test654888\r$ heroku buildpacks:add --index 1 heroku/nodejs\r$ heroku buildpacks:add --index 2 heroku/python\r$ heroku config:set FLASK_ENV=production\r$ heroku config:set FLASK_SECRET=my_secret_key\r$ git push heroku\rЕсли еще не было коммитов в ветку мастер на heroku, то пишем git push --set-upstream heroku master, далее можно просто писать git push heroku. Если все прошло удачно, открываем написанную внизу лога ссылку:\n{% img https://res.cloudinary.com/swasher/image/upload/v1557671350/blog/flask-vue-5.png %}\nМы видим название ОС, - наше приложение работает!\ntodo Есть одна нерешенная проблема, связанная со статикой в папке public. Описана тут issue\nOne button deploy Так как мы пилим темплейт для автоматического деплоя, настроим проект таким образом, чтобы он разворачивался на Heroku путем нажатия одной кнопки в репозитории Github. Создадим в корне файл app.json:\n{\r\u0026quot;name\u0026quot;: \u0026quot;Flask VueJs Heroku Template\u0026quot;,\r\u0026quot;description\u0026quot;: \u0026quot;template for automatic deploy flask-vue application\u0026quot;,\r\u0026quot;repository\u0026quot;: \u0026quot;https://github.com/swasher/flask-vuejs-heroku\u0026quot;,\r\u0026quot;logo\u0026quot;: \u0026quot;https://vuejs.org/images/logo.png\u0026quot;,\r\u0026quot;keywords\u0026quot;: [\u0026quot;flask\u0026quot;, \u0026quot;vue\u0026quot;, \u0026quot;heroku\u0026quot;],\r\u0026quot;env\u0026quot;: {\r\u0026quot;FLASK_ENV\u0026quot;: {\r\u0026quot;description\u0026quot;: \u0026quot;Flask Enviroment\u0026quot;,\r\u0026quot;value\u0026quot;: \u0026quot;production\u0026quot;\r},\r\u0026quot;SECRET\u0026quot;: {\r\u0026quot;description\u0026quot;: \u0026quot;Flask Secret Key\u0026quot;,\r\u0026quot;value\u0026quot;: \u0026quot;my_secret_key\u0026quot;\r}\r},\r\u0026quot;addons\u0026quot;: [\r],\r\u0026quot;buildpacks\u0026quot;: [\r{\r\u0026quot;url\u0026quot;: \u0026quot;heroku/nodejs\u0026quot;\r},\r{\r\u0026quot;url\u0026quot;: \u0026quot;heroku/python\u0026quot;\r}\r]\r}\rЗапилим красивую кнопку в файле README.md:\n|One button Installer | [![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy) |\r|---------------------|-------------------------------------------------------------------------------------|\rРепозиторий кода из этой статьи на github. В в репе имеется красивая кнопка, при нажатии на которую код из репозитория автоматически деплоится на heroku.\nDevelop server Когда мы подгоняли код под деплой на продакшен, наша локальная тестовая среда поломалась. Попробуем запустить в отдельных терминалах Vue npm run serve и Flask flask run и посмотрим, что у нас работает:\nна порту 8080 есть наша страничку, но она не получает данные с бекенда (Server working on: Unknown). на порту 5000 увидим ошибку FileNotFoundError, - это потому, что у нас отсутствует index.html, который есть на продакшене. на порту 5000 по ссылке /json увидим наши данные в формате json. Для нас сейчас главное - чтобы Vue получал данные с localhost:5000/json. Для этого мы будем использовать проксирование - перенаправлять все неизвестные запросы от Vue на localhost:5000. Таким образом, когда axios обратится по ссылке /json, он попадет на localhost:5000/json. Добавим в файл vue.config.js секцию devServer:\n::js\rdevServer: {\rproxy: {\r'^/*': {\rtarget: 'http://localhost:5000/',\r},\r},\r},\rперезапустим dev-сервер Vue, и снова посмотрим в браузер - фронтэнд получает данные от фласк. Так же у нас должен работать Hot Reloading - при изменении компонентов Vue.js браузер будет отображать эти изменения без перезагрузки страницы.\nПродолжение Вторая часть - наводим феншуй\ntodo: project structure ","permalink":"https://swasher.github.io/posts/vue-flask-heroku/","summary":"Задача - написать минимальное, но хорошо структурированое приложение-темплейт, использующее в качестве бекенда Flask, фронтэнд - Vue.js, в качестве хоста используем PaaS платформу Heroku. База данных, конечно, Postges, локально для девелопинга SQLite [уточнить], в качестве ORM для Flask я выбрал Peewee вместо обычной SQLAlchemy.\nЭта статья не призвана учить азам vue или flask, больше упор делается на соеденение всех компонентов стека. Поэтому объяснений самого кода будет минимум.\nПервая, неудачная попытка была создать структуру проекта с папками frontend и backend:","title":"Создание темплейта Flask-Vue.js-Heroku"}]